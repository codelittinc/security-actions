name: Reusable Security Scan

on:
  workflow_call:

# Minimal permissions for security
permissions:
  contents: read

jobs:
  secret-scan:
    name: TruffleHog Secret Scan
    runs-on: ubuntu-latest

    # Set minimal permissions for this job
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install TruffleHog (Secure)
        continue-on-error: true
        run: |
          # Pin to specific version for reproducibility and security
          TRUFFLEHOG_VERSION="3.90.2"
          TRUFFLEHOG_ARCH="linux_amd64"
          TRUFFLEHOG_BINARY="trufflehog_${TRUFFLEHOG_VERSION}_${TRUFFLEHOG_ARCH}.tar.gz"
          TRUFFLEHOG_CHECKSUMS="trufflehog_${TRUFFLEHOG_VERSION}_checksums.txt"

          printf "🔒 Installing TruffleHog v%s\n" "$(printf %q "$TRUFFLEHOG_VERSION")"

          # Create temporary directory
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"

          # Download binary from GitHub releases (more secure than raw script)
          echo "📥 Downloading TruffleHog binary..."
          curl -sSfL -o "$(printf %q "$TRUFFLEHOG_BINARY")" \
            "https://github.com/trufflesecurity/trufflehog/releases/download/v$(printf %q "$TRUFFLEHOG_VERSION")/$(printf %q "$TRUFFLEHOG_BINARY")"

          # Download checksums file with correct filename format
          echo "📥 Downloading checksums..."
          curl -sSfL -o "$(printf %q "$TRUFFLEHOG_CHECKSUMS")" \
            "https://github.com/trufflesecurity/trufflehog/releases/download/v$(printf %q "$TRUFFLEHOG_VERSION")/$(printf %q "$TRUFFLEHOG_CHECKSUMS")"

          # Verify checksum
          echo "🔍 Verifying checksum..."
          if ! grep "$(printf %q "$TRUFFLEHOG_BINARY")" "$(printf %q "$TRUFFLEHOG_CHECKSUMS")" | sha256sum -c -; then
            echo "❌ Checksum verification failed!"
            exit 1
          fi
          echo "✅ Checksum verified successfully"

          # Extract and install
          echo "📦 Extracting TruffleHog..."
          tar -xzf "$(printf %q "$TRUFFLEHOG_BINARY")"

          # Move to system path with proper permissions
          sudo install -m 755 trufflehog /usr/local/bin/trufflehog

          # Cleanup
          cd /
          rm -rf "$(printf %q "$TEMP_DIR")"

          # Verify installation
          echo "🔍 Verifying installation..."
          trufflehog --version
          echo "✅ TruffleHog installed successfully"

      - name: Run TruffleHog Scan
        continue-on-error: true
        run: |
          # Get the default branch and current commit with proper escaping
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          CURRENT_COMMIT="${{ github.sha }}"
          CURRENT_BRANCH="${{ github.ref_name }}"

          # Check if we're on the default branch
          if [ "$(printf %q "$CURRENT_BRANCH")" = "$(printf %q "$DEFAULT_BRANCH")" ]; then
            # On default branch - scan only the pushed commits
            BEFORE_COMMIT="${{ github.event.before }}"
            if [ "$(printf %q "$BEFORE_COMMIT")" = "0000000000000000000000000000000000000000" ] || [ -z "$BEFORE_COMMIT" ]; then
              SINCE_COMMIT="HEAD~1"
              echo "🔍 First commit on default branch"
              printf "📋 Scanning from: %s\n" "$(printf %q "$SINCE_COMMIT")"
            else
              SINCE_COMMIT="$BEFORE_COMMIT"
              printf "🔍 Push to default branch (%s)\n" "$(printf %q "$DEFAULT_BRANCH")"
              printf "📋 Scanning from: %s\n" "$(printf %q "$BEFORE_COMMIT")"
            fi
            printf "📋 Scanning to: %s\n" "$(printf %q "$CURRENT_COMMIT")"
          else
            # On feature branch - scan all commits not in default branch
            SINCE_COMMIT="origin/$DEFAULT_BRANCH"
            echo "🔍 Feature branch detected"
            printf "📋 Scanning all commits in '%s' not in '%s'\n" "$(printf %q "$CURRENT_BRANCH")" "$(printf %q "$DEFAULT_BRANCH")"
            printf "📋 Scanning from: %s\n" "$(printf %q "$SINCE_COMMIT")"
            printf "📋 Scanning to: %s\n" "$(printf %q "$CURRENT_COMMIT")"
          fi

          printf "🌿 Branch: %s\n" "$(printf %q "$CURRENT_BRANCH")"
          echo ""
          echo "📝 Commits to be scanned:"
          if [ "$(printf %q "$CURRENT_BRANCH")" = "$(printf %q "$DEFAULT_BRANCH")" ]; then
            git log --oneline "$(printf %q "$SINCE_COMMIT")..$(printf %q "$CURRENT_COMMIT")" || echo "No commits found in range"
          else
            git log --oneline "origin/$(printf %q "$DEFAULT_BRANCH")..HEAD" || echo "No commits found in range"
          fi
          echo ""

          # Run TruffleHog with improved error handling and logging
          echo "🔍 Running TruffleHog..."
          set +e  # Don't exit on error, we want to capture the exit code

          trufflehog git file://. \
            --since-commit="$(printf %q "$SINCE_COMMIT")" \
            --branch="HEAD" \
            --no-verification \
            --force-skip-binaries \
            --force-skip-archives \
            --no-update \
            --json \
            --log-level=2 \
            > trufflehog_output.json 2>&1

          TRUFFLEHOG_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          printf "📊 TruffleHog scan completed with exit code: %d\n" "$TRUFFLEHOG_EXIT_CODE"

          # Exit with the same code TruffleHog used
          exit $TRUFFLEHOG_EXIT_CODE

      - name: Process TruffleHog Results
        if: always()
        run: |
          # Filter out log messages, keep only actual findings (lines with SourceMetadata)
          grep '"SourceMetadata"' trufflehog_output.json > findings.json 2>/dev/null || touch findings.json

          if [ -s findings.json ]; then
            TOTAL_COUNT=$(wc -l < findings.json)
            printf "Found %d secret findings\n" "$TOTAL_COUNT"
          else
            echo "No secret findings detected"
          fi

      - name: Security Alert
        if: always()
        continue-on-error: true
        run: |
          # Check if we have findings directly
          if [ -f findings.json ] && [ -s findings.json ]; then
            TOTAL_COUNT=$(wc -l < findings.json)
            echo "🚨 SECURITY BREACH DETECTED 🚨"
            echo ""
            printf "TruffleHog detected %d potential credential(s).\n" "$TOTAL_COUNT"
            echo ""
            
            
            echo "IMMEDIATE ACTION REQUIRED:"
            echo "1. 🔄 ROTATE ALL DETECTED KEYS/SECRETS IMMEDIATELY"
            echo "2. 🧹 Review the raw output above to identify which files contain secrets"
            echo "3. 📝 Remove the secrets from your code and update configurations"
            echo "4. 🔍 Look for 'file' fields in the JSON above for exact file locations"
            echo "5. 🔍 Look for 'commit' fields to see which commits introduced the secrets"
            echo ""
            echo "💡 Manual review required - check the JSON output above for:"
            echo "   • File paths (look for 'file': fields)"
            echo "   • Commit hashes (look for 'commit': fields)"
            echo "   • Secret types (look for 'DetectorName': fields)"
            echo ""
            echo "⚠️  Once committed to Git, consider these credentials compromised!"
          else
            echo "✅ No secrets detected"
          fi
          echo ""
          exit 1

      - name: Send Security Alert to Webhook
        if: always()
        continue-on-error: true
        env:
          # Webhook URL set directly in the base workflow
          SECURITY_WEBHOOK_URL: ${{ secrets.SECURITY_WEBHOOK_URL }}
          # Escape GitHub context variables
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          # Check if we have findings directly
          if [ -f findings.json ] && [ -s findings.json ]; then
            echo "📡 Sending security alert to webhook..."
            
            TOTAL_COUNT=$(wc -l < findings.json)
            
            # Create sanitized findings by redacting the Raw field
            echo "Sanitizing findings to redact sensitive information..."
            cat findings.json | jq -c '. + {"Raw": "***REDACTED***", "RawV2": "***REDACTED***"}' > sanitized_findings.json
            
            # Create payload with repository context and sanitized findings
            # Use jq to properly escape all variables in JSON
            jq -n \
              --arg repository "$(printf %q "$GITHUB_REPOSITORY")" \
              --arg branch "$(printf %q "$GITHUB_REF_NAME")" \
              --arg commit "$(printf %q "$GITHUB_SHA")" \
              --arg actor "$(printf %q "$GITHUB_ACTOR")" \
              --arg workflow_run_url "$(printf %q "$GITHUB_SERVER_URL")/$(printf %q "$GITHUB_REPOSITORY")/actions/runs/$(printf %q "$GITHUB_RUN_ID")" \
              --argjson secrets_count "$TOTAL_COUNT" \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --slurpfile findings sanitized_findings.json \
              '{
                repository: $repository,
                branch: $branch,
                commit: $commit,
                actor: $actor,
                workflow_run_url: $workflow_run_url,
                secrets_count: $secrets_count,
                timestamp: $timestamp,
                findings: $findings
              }' > webhook_payload.json
            
            # Send to webhook with improved error handling and security headers
            if curl -X POST \
              -H "Content-Type: application/json" \
              -H "User-Agent: GitHub-Actions-Security-Scanner/1.0" \
              -d @webhook_payload.json \
              "$(printf %q "$SECURITY_WEBHOOK_URL")" \
              --max-time 30 \
              --retry 2 \
              --retry-delay 5 \
              --fail-with-body \
              --silent \
              --show-error; then
              echo "✅ Security alert sent successfully"
            else
              echo "❌ Failed to send security alert to webhook"
            fi
            
            # Clean up sensitive payload file
            rm -f webhook_payload.json sanitized_findings.json
          else
            echo "No secrets detected - skipping webhook notification"
          fi

      - name: Fail Build After Notification
        if: always()
        run: |
          # Check if we have findings directly
          if [ -f findings.json ] && [ -s findings.json ]; then
            echo "🚨 FAILING BUILD DUE TO DETECTED SECRETS 🚨"
            exit 1
          else
            echo "✅ No secrets detected - build can proceed"
          fi

  security-gate:
    name: Security Gate
    runs-on: ubuntu-latest
    needs: secret-scan
    if: always()

    # Set minimal permissions for this job
    permissions:
      contents: read

    steps:
      - name: Check secret scan result
        env:
          SECRET_SCAN_RESULT: ${{ needs.secret-scan.result }}
        run: |
          # Check if the secret-scan job failed (which means secrets were found)

          if [ "$(printf %q "$SECRET_SCAN_RESULT")" == "failure" ]; then
            echo "❌ Build blocked due to detected secrets"
            exit 1
          else
            echo "✅ No secrets detected - Build is secure"
          fi
